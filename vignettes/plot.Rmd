---
title: "Plot"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Plot}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```



```{r load packages, include=FALSE}
suppressPackageStartupMessages({
  library(dplyr)
  library(seahtrue)
  library(ggplot2)
})

# in your own workflow you don't have to supresses messages 
# off course, this is used here only for cleaner vignettes

```



```{r include=FALSE}
my_file_path <- 
  system.file("extdata", 
              "20191219_SciRep_PBMCs_donor_A.xlsx", 
              package = "seahtrue")

revive_output_donor_A <- my_file_path %>% revive_xfplate()

```

Generating visual output of the revived data can be done in multiple ways. We will provide a number of examples here.

#### Plate maps

Typically, scientists use multiple conditions in their 96 well plate set-up. These conditions are labeled as groups. Each group typically is associated with multiple wells. We can plot a plate-map using the `sketch_plate()` function.

```{r}
revive_output_donor_A %>%
  purrr::pluck("raw_data", 1)  %>%
  sketch_plate(reorder_legend = TRUE)

```

Apart from using the build in function for the most common type of plate map often needed, we can build our a heatmap with OCR data as well. We now use a similar ggplot script as in the `sketch_plate()` function but adapt to our liking show OCR instead of groups.

```{r}
  revive_output_donor_A %>%
    purrr::pluck("rate_data", 1) %>% 
    slice(1, .by = c(well)) %>% 
    tidyr::separate(well, 
                    into = c("row", "column"), 
                    sep = 1,  
                    convert = TRUE) %>% 
    ggplot(aes(x = column, y = forcats::fct_rev(row))) +
      geom_tile(aes(fill = OCR_wave_bc),
                color = "grey50",show.legend = TRUE)+
      colorspace::scale_fill_continuous_sequential(
        palette = "YlGnBu", 
        rev= TRUE,
        name = "OCR (pmol/min)")+
      scale_x_continuous(limits= c(0.5, 12.5),
                        breaks = c(1:12),
                        position = "top")+
      theme_bw(base_size = 15) %+replace% 
        theme(panel.grid = element_blank(),
              panel.border = element_blank(),
              axis.ticks = element_line(),
              axis.title = element_blank(),
              axis.text.x = element_text(size = rel(1.3),
                                          hjust = 0.5,
                                         vjust = 0),
              axis.text.y = element_text(size = rel(1.3),
                                         hjust = 0.5,
                                         vjust = 0.5),
              legend.justification = c(0,1))

```

Furthermore, we can annotate the wells with text as well. For example with the cell number:

```{r}
  revive_output_donor_A %>%
    purrr::pluck("rate_data", 1) %>% 
    slice(1, .by = c(well)) %>% 
    tidyr::separate(well, 
                    into = c("row", "column"), 
                    sep = 1,  
                    convert = TRUE) %>% 
    ggplot(aes(x = column, y = forcats::fct_rev(row))) +
      geom_tile(aes(fill = OCR_wave_bc),
                color = "grey50",show.legend = TRUE)+
      geom_text(aes(label = round(cell_n/100)), size = 2.5) +
      colorspace::scale_fill_continuous_sequential(
        palette = "YlGnBu", 
        rev= TRUE,
        name = "OCR (pmol/min)")+
      scale_x_continuous(limits= c(0.5, 12.5),
                        breaks = c(1:12),
                        position = "top")+
      theme_bw(base_size = 15) %+replace% 
        theme(panel.grid = element_blank(),
              panel.border = element_blank(),
              axis.ticks = element_line(),
              axis.title = element_blank(),
              axis.text.x = element_text(size = rel(1.3),
                                          hjust = 0.5,
                                         vjust = 0),
              axis.text.y = element_text(size = rel(1.3),
                                         hjust = 0.5,
                                         vjust = 0.5),
              legend.justification = c(0,1))

```

#### Rate plot

The most common plot that is often seen in papers is the rate plot. This shows most of the time the OCR (or ECAR) traces per group over time, demonstrating the different phases of an XF assay, such as basal, maximal and non-mitochondrial OCR. The sketch_rate() function can be used for this. It has some options that we will explore here.

First, let's plot the OCR for each group in an assy over time. Please note that the shaded area is the 50% middle quantiles as generated by the R `quantile` function.

```{r}

revive_output_donor_A %>%
  purrr::pluck("rate_data", 1)  %>%
  sketch_rate(reorder_legend = TRUE)

```

It can also be informative to observe all OCR of each individual well. This could be used to spot technical outliers.

```{r}

revive_output_donor_A %>%
  purrr::pluck("rate_data", 1)  %>%
  sketch_rate(reorder_legend = TRUE,
              take_group_mean = FALSE)

```
Since XF data needs to be properly normalized to cell number in each, this option can be selected. If the cell numbers were in the original .xlsx input file, the `cell_n` column contains these normalization values:

```{r}

revive_output_donor_A %>%
  purrr::pluck("rate_data", 1)  %>%
  sketch_rate(param = "OCR",
              reorder_legend = TRUE,
              take_group_mean = TRUE,
              normalize = TRUE,
              normalize_unit = "1000")

```

Similar plots can be generated for ECAR.

```{r}

revive_output_donor_A %>%
  purrr::pluck("rate_data", 1)  %>%
  sketch_rate(param = "ECAR",
              reorder_legend = TRUE,
              take_group_mean = TRUE,
              normalize = TRUE,
              normalize_unit = "1000")

```

Or for single wells:

```{r}

revive_output_donor_A %>%
  purrr::pluck("rate_data", 1)  %>%
  sketch_rate(param = "ECAR",
              reorder_legend = TRUE,
              take_group_mean = FALSE,
              normalize = TRUE,
              normalize_unit = "1000")

```


#### Multiple plates

To be able to inspect, compare and visulaize multiple plates the `glue_xfplates()` function can be used. This reads in either a path to a folder or a vector with a strings containing a full file path to .xlsx XF files. If the argument is a folder  path the `arg_is_folder` argument should be `TRUE`, if vector it should be `FALSE`.

```{r}


my_filepath_vector <- 
  c(system.file("extdata",
      "20191219_SciRep_PBMCs_donor_A.xlsx", 
      package = "seahtrue"),
    system.file("extdata",
      "20200110_SciRep_PBMCs_donor_B.xlsx", 
      package = "seahtrue"),
   system.file("extdata",
      "20200110_SciRep_PBMCs_donor_C.xlsx", 
      package = "seahtrue"))

  revived_donors <- 
    my_filepath_vector %>%
      glue_xfplates(arg_is_folder = FALSE)


revived_donors

```

Next, we can unnest particular data tibbles which combines the data of the three plates into one tibble.

```{r}

revived_donors %>% 
  select(plate_id, "raw_data") %>% 
  tidyr::unnest(raw_data)


```

The `sketch_assimilate_rate()` function plots the OCR for specific measurements that are given in the `my_measurements` argument for each well. The three different plates are faceted into separate panels. The plate barcode is given as facet title. Also the dots (representing a well) are color based on their interval in the XF experiment. This information comes from the `injection_info` tibble. In our demo data the first interval is initial OCR, the second interval is the FCCP-induced OCR and the third and fourth interval are antimycin/rotenone induced OCR.

```{r}

revived_donors %>% 
  sketch_assimilate_rate(my_measurements = c(3,4,9,12))

```

A similar plot can be generaetd for ECAR:

```{r}

revived_donors %>% 
  sketch_assimilate_rate(param = "ECAR",
                         my_measurements = c(3,4,9,12))

```
Also, we could plot only the measurments belonging to the initial ECAR and final ECAR by changing the `my_measurements` vector. This shows the initial and maximal ECAR for each group in all three plates cmobined.

```{r}

revived_donors %>% 
  sketch_assimilate_rate(param = "ECAR",
                         my_measurements = c(1,2,3, 10, 11, 12))

```

#### Plot multiple plate with raw data

If we combine the raw data tibbles form the three plates we can get insights into the raw O2 or pH levels. For example, by plotting the first tick, whcih is the first point of the first measurement, for each well in each plate a distribution is observed around the target O2.

```{r}

revived_donors %>% 
  sketch_assimilate_raw(param = "O2_mmHg")

```

And the same can be done for the emission of the pH values for example:

```{r}

revived_donors %>% 
  sketch_assimilate_raw(param = "pH_em_corr")

```
